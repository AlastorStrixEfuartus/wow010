#include "basics.h"

typedef C2Vector uv;

struct M2Array
{
   uint32_t number;
   uint32_t offset_elements;
 };

struct M2TrackHead
{
    enum<uint16_t>
    {
        NO_INTERPOLATION,
        LINEAR,
        HERMITE,
        BEZIER,
    } interpolation_type;
    int16_t global_sequence;
};
struct M2TrackBase
  {
  M2TrackHead header;
  uint32_t nTimelinesForTimestamps;
  uint32_t ofsTimelinesForTimestamps;
};

struct M2Track
{
  M2TrackHead header;
  uint32_t nTimelinesForTimestamps;
  uint32_t ofsTimelinesForTimestamps;
  uint32_t nTimelinesForKeys;
  uint32_t ofsTimelinesForKeys;
};

struct M2TrackNoHeader
{
  uint32_t nTimelinesForTimestamps;
  uint32_t ofsTimelinesForTimestamps;
  uint32_t nTimelinesForKeys;
  uint32_t ofsTimelinesForKeys;
};

local int startPos = 0;

string get_tex_name( int offset )
{
  FSeek( offset + startPos );
  return ReadString( FTell() );
}

string get_m2array_filename( M2Array& arr )
{
  FSeek( arr.offset_elements + startPos );
  return ReadString( FTell() );
}

enum XPAC
{
  CLASSIC,
  TBC,
  WOTLK,
  CATA,
  MOP,
  WOD,
  LEGION,
};

local XPAC xpac;

XPAC SetXpac( uint32_t Version )
{
    if( Version > 274 ) return LEGION;
    if( Version > 272 ) return WOD;
    if( Version == 272 ) return MOP;
    if( Version > 265 ) return CATA;
    if( Version == 264 ) return WOTLK;
    if( Version > 260 ) return TBC;
    return CLASSIC;
}

struct M2
{
    // Legion chunk?
    startPos = FTell();
    uint32_t magic <hidden=true>;
    if( magic == 0x3132444D ) // MD21
    {
        uint32_t size <hidden=true>;
        startPos = FTell();
        uint32_t magic2 <hidden=true>;
        Assert( magic2 == 0x3032444D, "only MD20 here!");
    }
    else
    {
        Assert( magic == 0x3032444D, "only MD20 here!");
    }

    // Header
    struct
    {
	    uint32_t Version;
        xpac = SetXpac( Version );
	    uint32_t lName;
	    uint32_t ofsName;

        struct
        {
            uint32_t TILT_X : 1;
            uint32_t TILT_Y : 1;
            uint32_t UNK_0x4 : 1;
            uint32_t HAS_BLENDMODE_OVERRIDES : 1;
            uint32_t UNK_0x10 : 1;
            uint32_t LOAD_PHYSICS_DATA : 1;
            uint32_t UNK_0x40 : 1;
            uint32_t HAS_LOD_SKIN_FILES : 1;
            uint32_t UNK_0x100_CAMERA_RELATED : 1;
            uint32_t UNK_0x200 : 1;
            uint32_t UNK_0x400 : 1;
            uint32_t UNK_0x800 : 1;
            uint32_t UNK_0x1000 : 1;
            uint32_t UNK_0x2000 : 1;
            uint32_t UNK_0x4000 : 1;
            uint32_t UNK_0x8000 : 1;
        } GlobalModelFlags;

	    uint32_t nGlobalSequences;
	    uint32_t ofsGlobalSequences;
	    uint32_t nAnimations;
	    uint32_t ofsAnimations;
	    uint32_t nAnimationLookup;
	    uint32_t ofsAnimationLookup;
	    uint32_t nBones;
	    uint32_t ofsBones;
	    uint32_t nKeyBoneLookup;
	    uint32_t ofsKeyBoneLookup;
	    uint32_t nVertices;
	    uint32_t ofsVertices;
	    uint32_t _nViews_deprecated;
	    uint32_t nColors;
	    uint32_t ofsColors;
	    uint32_t nTextures;
	    uint32_t ofsTextures;
	    uint32_t nTextureWeights;
	    uint32_t ofsTextureWeights;
	    uint32_t nUVAnimations;
	    uint32_t ofsUVAnimations;
	    uint32_t nTexReplace;
	    uint32_t ofsTexReplace;
	    uint32_t nMaterials;
	    uint32_t ofsMaterials;
	    uint32_t nBoneLookup;
	    uint32_t ofsBoneLookup;
	    uint32_t nTexLookup;
	    uint32_t ofsTexLookup;
	    uint32_t _nTexUnits_deprecated;
	    uint32_t _ofsTexUnits_deprecated;
	    uint32_t nTextureWeightsLookup;
	    uint32_t ofsTextureWeightsLookup;
	    uint32_t nUVAnimLookup;
	    uint32_t ofsUVAnimLookup;
	    CAaBox  VertexBox;
	    float  VertexRadius;
	    CAaBox  BoundingBox;
	    float  BoundingRadius;
	    uint32_t nBoundingTriangles;
	    uint32_t ofsBoundingTriangles;
	    uint32_t nBoundingVertices;
	    uint32_t ofsBoundingVertices;
	    uint32_t nBoundingNormals;
	    uint32_t ofsBoundingNormals;
	    uint32_t nAttachments;
	    uint32_t ofsAttachments;
	    uint32_t nAttachLookup;
	    uint32_t ofsAttachLookup;
	    uint32_t nEvents;
	    uint32_t ofsEvents;
	    uint32_t nLights;
	    uint32_t ofsLights;
	    uint32_t nCameras;
	    uint32_t ofsCameras;
	    uint32_t nCameraLookup;
	    uint32_t ofsCameraLookup;
	    uint32_t nRibbonEmitters;
	    uint32_t ofsRibbonEmitters;
	    uint32_t nParticleEmitters;
	    uint32_t ofsParticleEmitters;

        if( GlobalModelFlags.HAS_BLENDMODE_OVERRIDES )
        {
    	    uint32_t nBlendModeOverrides;
    	    uint32_t ofsBlendModeOverrides;
        }
    } header;

    // Name
    FSeek( header.ofsName + startPos );
    char name[ header.lName ];

    // Global Sequences
    FSeek( header.ofsGlobalSequences + startPos );
    uint32_t global_sequences[ header.nGlobalSequences ];

    // Animations
    FSeek( header.ofsAnimations + startPos );
    struct
    {
	    uint16_t animation_id;
	    uint16_t sub_animation_id;
	    uint32_t length;
	    float moving_speed;

        struct
        {
	        uint32_t SETS_0x80_WHEN_LOADED : 1;
	        uint32_t UNK_0x2	: 1;
	        uint32_t UNK_0x4	: 1;
	        uint32_t UNK_0x8 : 1;
	        uint32_t UNK_0x10 : 1;
	        uint32_t LOOPED : 1;
	        uint32_t HAS_NEXT_IS_ALIAS : 1;
	        uint32_t BLENDED_ANIMATION : 1;
	        uint32_t UNK_0x100 : 1;
	        uint32_t UNK_0x200 : 1;
	        uint32_t UNK_0x400 : 1;
	        uint32_t UNK_0x800 : 1;
	        uint32_t UNK_0x1000 : 1;
	        uint32_t UNK_0x2000 : 1;
	        uint32_t UNK_0x4000 : 1;
	        uint32_t UNK_0x8000 : 1;
        } Flags;

	    int16_t probability;
	    uint16_t _padding;
	    uint32_t minimum_repetitions;
	    uint32_t maximum_repetitions;
	    uint32_t blend_time;
	    C3Vector bounds_minimum_extent;
	    C3Vector bounds_maximum_extent;
	    float bound_radius;
	    int16_t next_animation;
	    uint16_t aliasNext;
    } animations[ header.nAnimations ];

    FSeek( header.ofsAnimationLookup + startPos );
    uint16_t animation_lookups[ header.nAnimationLookup ];

    // Bones
    FSeek( header.ofsBones + startPos );
    struct
    {
        int32 key_bone_id;

        struct
        {
	        uint32_t UNK_0x1 : 1;
	        uint32_t UNK_0x2 : 1;
	        uint32_t UNK_0x4 : 1;
	        uint32_t SPHERICAL_BILLBOARD : 1;
	        uint32_t CYLINDRICAL_BILLBOARD_LOCK_X : 1;
	        uint32_t CYLINDRICAL_BILLBOARD_LOCK_Y : 1;
	        uint32_t CYLINDRICAL_BILLBOARD_LOCK_Z : 1;
	        uint32_t UNK_0x80 : 1;
	        uint32_t UNK_0x100 : 1;
	        uint32_t TRANSFORMED : 1;
	        uint32_t KINEMATIC_BONE : 1;
	        uint32_t UNK_0x800 : 1;
	        uint32_t HELMET_ANIM_SCALED : 1;
        } flags;

        int16_t parent_bone;
        uint16_t submesh_id;
        uint16_t _unknown[2];
        M2Track translation; // C3Vector
        M2Track rotation; // struct M2CompQuat { int16_t val[4]; };
        M2Track scale; // C3Vector
        C3Vector pivot;
    } bones[ header.nBones ];

    FSeek( header.ofsBoneLookup + startPos );
    uint16_t bone_lookups[ header.nBoneLookup ];

    FSeek( header.ofsKeyBoneLookup + startPos );
    enum<int16>
    {
        NO_KEY_BONE = -1,
        ARM_L,
        ARM_R,
        SHOULDER_L,
        SHOULDER_R,
        SPINE_LOW,
        WAIST,
        HEAD,
        JAW,
        INDEX_FINGER_R,
        MIDDLE_FINGER_R,
        PINKY_FINGER_R,
        RING_FINGER_R,
        THUMB_R,
        INDEX_FINGER_L,
        MIDDLE_FINGER_L,
        PINKY_FINGER_L,
        RING_FINGER_L,
        THUMB_L,
        $BTH,
        $CSR,
        $CSL,
        _BREATH,
        _NAME,
        _NAMEMOUNT,
        $CHD,
        $CCH,
        ROOT,
        WHEEL1,
        WHEEL2,
        WHEEL3,
        WHEEL4,
        WHEEL5,
        WHEEL6,
        WHEEL7,
        WHEEL8,
    } key_bone_lookups[ header.nKeyBoneLookup ];

    // Vertices
    FSeek( header.ofsVertices + startPos );
    struct
    {
        C3Vector position;
        ubyte bone_weights[4];
        ubyte bone_indices[4];
        C3Vector normal;
        uv texcoords1;
        uv texcoords2;
    } vertices[ header.nVertices ];

    // Color/Alpha animations
    FSeek( header.ofsColors + startPos );
    struct
    {
        M2Track color; // C3Vector
        M2Track alpha; // uint16_t
    } colors[ header.nColors ];

    // Textures
    FSeek( header.ofsTextures + startPos );
    struct
    {
        enum<uint32_t>
        {
            GIVEN_IN_FILENAME,
            BODY_AND_CLOTHES,
            ITEM,
            WEAPON_BLADE,
            WEAPON_HANDLE,
            ENVIRONMENT,
            CHARACTER_HAIR,
            CHARACTER_FACIAL_HAIR,
            SKIN_EXTRA,
            UI_SKIN,
            TAUREN_MANE,
            CREATURE_SKIN_1,
            CREATURE_SKIN_2,
            CREATURE_SKIN_3,
            ITEM_ICON,
            GUILD_BACKGROUND_COLOR,
            GUILD_EMBLEM_COLOR,
            GUILD_BORDER_COLOR,
            GUILD_EMBLEM,
        } type;
        struct
        {
            uint32_t TEXTURE_WRAP_X : 1;
            uint32_t TEXTURE_WRAP_Y : 1;
        } flags;
        uint32_t lenFilename;
        uint32_t ofsFilename <comment=get_tex_name>;
    } textures[ header.nTextures ];

    FSeek( header.ofsTexLookup + startPos );
    uint16_t texture_lookups[ header.nTexLookup ];

    FSeek( header.ofsTexReplace + startPos );
    int16_t texture_replacements[ header.nTexReplace ];

    // Texture Weights (was Transparency)
    FSeek( header.ofsTextureWeights + startPos );
    M2Track texture_weights[ header.nTextureWeights ]; // uint16_t

    FSeek( header.ofsTextureWeightsLookup + startPos );
    uint16_t texture_weights_lookup[ header.nTextureWeightsLookup ];

    // UV Animations
    FSeek( header.ofsUVAnimations + startPos );
    struct
    {
        M2Track translation; // C3Vector
        M2Track rotation; // C4Vector
        M2Track scaling; // C3Vector
    } uv_animations[ header.nUVAnimations ];

    FSeek( header.ofsUVAnimLookup + startPos );
    uint16_t uv_animation_lookups[ header.nUVAnimLookup ];

    // Materials (was Render Flags)
    FSeek( header.ofsMaterials + startPos );
    struct
    {
        struct
        {
            uint16_t UNLIT : 1;
            uint16_t UNFOGGED : 1;
            uint16_t TWOSIDED : 1;
            uint16_t BILLBOARD : 1;
            uint16_t DISABLE_ZBUFFER : 1;
            uint16_t UNK_0x20 : 1;
            uint16_t UNK_0x40_SHADOW_BATCH_RELATED : 1;
            uint16_t UNK_0x80_SHADOW_BATCH_RELATED : 1;
            uint16_t UNK_0x100 : 1;
            uint16_t UNK_0x200 : 1;
            uint16_t UNK_0x400 : 1;
            uint16_t PREVENT_ALPHA: 1;
        } flags;
        enum<uint16_t>
        {
            OPAQUE,
            MOD,
            DECAL,
            ADD,
            MOD2X,
            FADE,
            DEEPRUN_TRAM,
            UNK_WOD,
        } blendMode;
    } materials[ header.nMaterials ];

    // Bounding Volumes
    FSeek( header.ofsBoundingVertices + startPos );
    C3Vector bounding_vertices[ header.nBoundingVertices ];

    FSeek( header.ofsBoundingTriangles + startPos );
    uint16_t bounding_triangles[ header.nBoundingTriangles ];

    FSeek( header.ofsBoundingNormals + startPos );
    C3Vector bounding_normals[ header.nBoundingNormals];

    // Attachments
    FSeek( header.ofsAttachments + startPos );
    struct
    {
        enum<uint32_t>
        {
            SHIELD = 0,
            MOUNTMAIN = 0,
            ITEM_VISUAL_0 = 0,
            HAND_RIGHT = 1,
            ITEM_VISUAL_1 = 1,
            HAND_LEFT = 2,
            ITEM_VISUAL_2 = 2,
            ELBOW_RIGHT = 3,
            ITEM_VISUAL_3 = 3,
            ELBOW_LEFT = 4,
            ITEM_VISUAL_4 = 4,
            SHOULDER_RIGHT,
            SHOULDER_LEFT,
            KNEE_RIGHT,
            KNEE_LEFT,
            HIP_RIGHT,
            HIP_LEFT,
            HELM,
            BACK,
            SHOULDER_FLAP_RIGHT,
            SHOULDER_FLAP_LEFT,
            CHEST_BLOOD_FRONT,
            CHEST_BLOOD_BACK,
            BREATH,
            PLAYER_NAME,
            BASE,
            HEAD_,
            SPELL_LEFT_HAND,
            SPELL_RIGHT_HAND,
            SPECIAL_1,
            SPECIAL_2,
            SPECIAL_3,
            SHEATH_MAIN_HAND,
            SHEATH_OFF_HAND,
            SHEATH_SHIELD,
            PLAYER_NAME_MOUNTED,
            LARGE_WEAPON_LEFT,
            LARGE_WEAPON_RIGHT,
            HIP_WEAPON_LEFT,
            HIP_WEAPON_RIGHT,
            CHEST,
            HAND_ARROW,
            BULLET,
            SPELL_HAND_OMNI,
            SPELL_HAND_DIRECTED,
            VEHICLE_SEAT_1,
            VEHICLE_SEAT_2,
            VEHICLE_SEAT_3,
            VEHICLE_SEAT_4,
            VEHICLE_SEAT_5,
            VEHICLE_SEAT_6,
            VEHICLE_SEAT_7,
            VEHICLE_SEAT_8,
            LEFT_FOOT,
            RIGHT_FOOT,
            SHIELD_NO_GLOVE,
            SPINE_LOW_,
            ALTERED_SHOULDER_R,
            ALTERED_SHOULDER_L,
            BELT_BUCKLE,
            SHEATH_CROSSBOW,
        } id;

        uint32_t bone;
        C3Vector position;
        M2Track anim; // uchar
    } attachments[ header.nAttachments ];

    FSeek( header.ofsAttachLookup + startPos );
    int16_t attachment_lookups[ header.nAttachLookup ];

    // Events
    FSeek( header.ofsEvents + startPos );
    struct
    {
	    char identifier[4];
	    uint32_t data;
	    uint32_t bone;
	    C3Vector position;
        M2TrackBase anim;
    } events[ header.nEvents ];

    // Lights
    FSeek( header.ofsLights + startPos );
    struct
    {
        enum<uint16_t>
        {
            DIRECTIONAL,
            POINT,
        } type;

        int16_t bone;
        C3Vector position;
        M2Track ambient_color; // C3Vector
        M2Track ambient_intensity; // float
        M2Track diffuse_color; // C3Vector
        M2Track diffuse_intensity; // float
        M2Track attenuation_start; // float
        M2Track attenuation_end; // float
        M2Track attenuation_unknown; // uchar
    } lights[ header.nLights ];

    // Cameras
    FSeek( header.ofsCameras + startPos );
    struct
    {
        enum<int32>
        {
            FLYBY_ETC = -1,
            PORTRAIT,
            CHARACTER_INFO,
        } type;
        if( xpac < CATA )
        {
            float fov;
        }
        float far_clip;
        float near_clip;
        M2Track translation_position; // 3 * 3 floats (spline key)
        C3Vector position;
        M2Track translation_target; // 3 * 3 floats (spline key)
        C3Vector target;
        M2Track roll; // float
        if( xpac >= CATA )
        {
            M2Track fov;  // float
        }
    } cameras[ header.nCameras ];

    FSeek( header.ofsCameraLookup + startPos );
    uint16_t camera_lookups[ header.nCameraLookup ];

    // Ribbon Emitters
    FSeek( header.ofsRibbonEmitters + startPos );
    struct
    {
        int32 _unknown0;
        uint32_t bone;
        C3Vector position;
        M2Array texture_refs; // uint16_t
        M2Array blend_refs; // uint16_t
        M2Track color; // C3Vector
        M2Track opacity; // uint16_t;
        M2Track height_above; // float
        M2Track height_below; // float
        float edgesPerSec;
        float edgeLifeSpanInSec;
        float gravity;
        uint16_t m_rows;
        uint16_t m_cols;
        M2Track texSlot; // uint16_t
        M2Track dataEnabled; // uchar
        uint32_t _unknown1;
    } ribbon_emitters[ header.nRibbonEmitters ];

    // Particle Emitters
    FSeek( header.ofsParticleEmitters + startPos );
    struct M2ParticleEmitter
    {
        int32 unk0_always_minus_1;
        struct
        {
            uint32_t LIT : 1;
            uint32_t UNK_0x2 : 1;
            uint32_t UNK_0x4 : 1;
            uint32_t MOVE_IN_WORLD_SPACE : 1;
            uint32_t DO_NOT_TRAIL : 1;
            uint32_t UNLIT : 1;
            uint32_t UNK_0x40 : 1;
            uint32_t IN_MODEL_SPACE : 1;
            uint32_t UNK_0x100 : 1;
            uint32_t SPAWN_POSITION_RANDOMIZED : 1;
            uint32_t PINNED : 1;
            uint32_t UNK_0x800 : 1;
            uint32_t XY_QUAD : 1;
            uint32_t CLAMP_TO_GROUND : 1;
            uint32_t UNK_0x4000 : 1;
            uint32_t UNK_0x8000 : 1;
            uint32_t CHOOSE_RANDOM_TEXTURE : 1;
            uint32_t OUTWARD : 1;
            uint32_t UNK_INWARD : 1;
            uint32_t SCALE_VARY_XY : 1;
            uint32_t UNK_0x100000 : 1;
            uint32_t RANDOM_FLIP_BOOK_START : 1;
            uint32_t UNK_0x400000 : 1;
            uint32_t COMPRESSED_GRAVITY_VALUES : 1;
            uint32_t BONE_GENERATOR_BONE_NOT_JOINT : 1;
            uint32_t UNK_0x2000000 : 1;
            uint32_t DO_NOT_THROTTLE_EMISSION_RATE_BASED_ON_DISTANCE : 1;
            uint32_t UNK_0x8000000 : 1;
            uint32_t MULTI_TEXTURING : 1;
        } flags;

        C3Vector position;
        uint16_t bone;
        if( flags.MULTI_TEXTURING )
        {
            uint16_t texture_0 : 5;
            uint16_t texture_1 : 5;
            uint16_t texture_2 : 5;
            uint16_t _ : 1;
        }
        else
        {
           uint16_t texture;
        }

        M2Array model_filename <comment=get_m2array_filename>; // uchar
        M2Array child_emitter_filename <comment=get_m2array_filename>; // uchar
        enum<ubyte>
        {
            PARTICLE_BLEND_NONE,
            PARTICLE_BLEND_SRC_COLOR___ONE,
            PARTICLE_BLEND_SRC_ALPHA___ONE_MINUS_SRC_ALPHA,
            PARTICLE_BLEND___ALPHA_TEST,
            PARTICLE_BLEND_SRC_ALPHA___ONE,
        } blending_type;
        enum<ubyte>
        {
            PLANE = 1,
            SPHERE,
            SPLINE,
            BONE,
        } emitter_type;
        uint16_t particle_color_index;
        ubyte _unk_0x02c; // was type?
        ubyte _unk_0x02d; // was headortail?
        uint16_t texture_tile_rotation;
        uint16_t texture_dimensions_rows;
        uint16_t texture_dimensions_columns;
        M2Track emission_speed; // float
        M2Track speed_variation; // float
        M2Track vertical_range; // float
        M2Track horizontal_range; // float
        M2Track gravity; // float
        M2Track lifespan; // float
        float lifespan_vary;
        M2Track emission_rate; // float
        float emission_rate_vary;
        M2Track emission_area_length; // float
        M2Track emission_area_width; // float
        M2Track z_source; // float
        M2TrackNoHeader colorTrack; // C3Vector
        M2TrackNoHeader alphaTrack; // uint16_t
        M2TrackNoHeader scaleTrack; // C2Vector
        C2Vector scale_vary;
        M2TrackNoHeader headCellTrack; // uint16_t
        M2TrackNoHeader tailCellTrack; // uint16_t
        float something_particle_style;
        float unk_spread1;
        float unk_spread2;
        C2Vector twinkleScale;
        float unk_;
        float drag;
        float base_spin;
        float base_spin_vary;
        float spin;
        float spin_vary;
        float unk2_;
        C3Vector model_1_rotation;
        C3Vector model_2_rotation;
        C3Vector model_translation;
        float followParams[4];
        uint32_t nUnknownReference;
        uint32_t ofsUnknownReference;
        M2Track enabled_in; // uchar

        if( xpac >= CATA )
        {
            uint32_t multi_texture_params0[2]; // actually fixed point type
            uint32_t multi_texture_params1[2]; // actually fixed point type
        }

    } particle_emitters[ header.nParticleEmitters ];
} m2;

